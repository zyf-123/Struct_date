/*一个正整数有可能可以被表示为n(n>=2)个连续正整数之和，如：
  15=1+2+3+4+5    15=4+5+6    15=7+8
请编写程序，根据输入的任何一个正整数，找出符合这种要求的所有连续正整数序列。
输入数据：一个正整数，以命令行参数的形式提供给程序。
输出数据：在标准输出上打印出符合题目描述的全部正整数序列，每行一个序列，
每个序列都从该序列的最小正整数开始、以从小到大的顺序打印。如果结果有多个序列，
按各序列的最小正整数的大小从小到大打印各序列。此外，序列不允许重复，序列内的
整数用一个空格分隔。如果没有符合要求的序列，输出“NONE”。
*/
#if 0;
#include<stdio.h>
#pragma warning (disable:4996)

void main()

{

	int input, i, n, flag;

	float a;//等差数列的首项不一定为整数

	flag = 0;

	printf("输入判断的整数:\n");

	scanf("%d", &input);

	for (n = 2; n <= input; n++)

	{

		a = (2 * input + n - n * n) / (2.0 * n);//求的首项 根据公式Sn=na1+n(n-1)d/2=n(a1+an)/2而来

		if (int(a) == a && a > 0)//如果为整整数，则满足要求

		{

			printf("%d=%d", input, int(a));//输出的序列为整数，a实质是整数，那么强制转化类型不影响结果

			for (i = 1; i <= n - 1; i++)

				printf("+%d", int(a + i));//等差数列的其他项也为整数，a+i实质是整数，装换类型

			printf("\n");

			flag++;//flag记录满足要求的数列数

		}

	}

	if (flag == 0)   //flag初始为0，通过上面的循环，如果有满足的在则不为0，为0则说明不能写成等差数列

		printf("%d不能被表示成n连续正整数之和\n", input);

}

#endif